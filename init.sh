#!/bin/bash
# Description:
# This script will setup your server with sshupdated. It offers you a way to create required package to spread to your clients in the same time.
# It generates the SSH-keys used in the different scripts.

### Variables
version=0.1

# ? What is this used for? Or well, intended to be used for
keys="sshupdated" 

# Which type of SSH-key do we want to use
keytype="rsa"

# What size should the key be
keysize=4096

# Which port do we want to run the server on
sshd_port=2222

# Where should we listen? Default: any ( any / inet6 )
sshd_inet="any"

# What do we call the service
# Please remember, the server does not run a daemon, only the client does that
server_service_name="sshupdate"
client_service_name="sshupdated"

# GPG STUFF
GPG_KEY=RSA
GPG_KEYSIZE=4096
GPG_SUBKEY=RSA
GPG_SUBKEYSIZE=4096
GPG_NAME="sshupdated signing key"
GPG_COMMENT="Autogenerated sshupdate signing key"
GPG_EMAIL="sshupdated@example.com"
GPG_EXPIRE="20161010T000000" #XXX FIXME
GPG_SECRING=$server_service_name
GPG_PUBRING=$server_service_name

# Figure out $MYDIR
MYDIR=$(dirname $0)
if [ "${MYDIR}" = "." ]
then
  MYDIR=$(pwd)
fi

# Where should we build the RPM
RPM_ROOT=${MYDIR}/RPM-ROOT

# Where should we build the DEB
DEB_ROOT=${MYDIR}/DEB-ROOT

# Where do we find the deps-directory
deps=${MYDIR}/deps

# Where is the pkgs directory found
pkgs=${MYDIR}/pkgs

### Sanity is good
# Making sure we have a sane path
PATH=/sbin:/usr/sbin:/bin:/usr/bin

RPMBUILD=/usr/bin/rpmbuild
TPUT=/usr/bin/tput

# Some variables needed for fancy output
COLS=$($TPUT cols)
COL=$(($COLS-8))
UP=$($TPUT cuu1)
START=$($TPUT hpa 0)
END=$($TPUT hpa $COL)
RED=$($TPUT setaf 1)
GREEN=$($TPUT setaf 2)
NORMAL=$($TPUT op)

### Functions

## General functions

# To be used to print success on a previous command, like so: print_success $?
function print_success {
  if [ $1 -eq 0 ]
  then
    STATUS="${GREEN}ok"
  else
    STATUS="${RED}fail"
  fi
  if [ ! -z "$2" ]
  then
    REASON=$2
    /bin/echo -e " [ ${STATUS}${NORMAL} ]\n  Reason: $REASON"
  else
    /bin/echo -e " [ ${STATUS}${NORMAL} ]"
  fi
}

# Used in conjunction with print_success
function print_line {
  if [ -z "$1" ]
  then
    echo
  else
    echo -en $@
  fi
}

function f_query_user {
  while true
  do
    echo -e "$1 [y/n]"
    echo -n "Answer: "
    read QUERY_ANSWER
    if [ "$2" = "check_file" ] || [ "$2" = "check_dir" ]
    then
      [ -e "$QUERY_ANSWER" ] && break
    elif [ "$2" = "yes_no" ]
    then
      if [[ "$QUERY_ANSWER" =~ ^[yY]*[eE]*[sS]*$ ]]
      then
        return 0
        break
      elif [[ "$QUERY_ANSWER" =~ ^[nN]*[oO]*$ ]]
      then
        return 1
        break
      fi
    else
      [ ! -z "$QUERY_ANSWER" ] && break
    fi
  done
}


function f_genkeys {
  print_line "Generating keys"
  for key in $keys; do
    if [ ! -f ${MYDIR}/keys/$key ]; then
      umask 077
      mkdir -p ${MYDIR}/keys	
      ssh-keygen -t $keytype -b ${keysize} -f ${MYDIR}/keys/${key} -N ""
      print_success $?
    else
      print_success $? "${client_service_name}-key already exist (${MYDIR}/keys/${key})"
    fi
  done
}

function f_populate_scripts {
  # Make sure directory exists
  [ -d "${RPM_ROOT}/usr/share/${client_service_name}" ] || mkdir -p ${RPM_ROOT}/usr/share/${client_service_name}
  [ -d "${RPM_ROOT}/usr/sbin" ] || mkdir -p ${RPM_ROOT}/usr/sbin
  # Install wrapper.sh
  [ -f "${deps}/el6/wrapper.sh" ] && cp ${deps}/el6/wrapper.sh ${RPM_ROOT}/usr/share/${client_service_name}
  # Install sshupdate
  [ -f "${deps}/common/sshupdate" ] && mkdir -p ${RPM_ROOT}/usr/sbin && cp ${deps}/common/sshupdate ${RPM_ROOT}/usr/sbin/sshupdate
}

## Deb functions

function f_create_client_package_deb {
  # Check if dpkg-deb exists
  [ -f "/usr/bin/dpkg-deb" ] || ( echo "No dpkg-deb existing, please install it so we can create deb's for you" ; exit 1 )
  # Create DEB_ROOT/sshupdated/DEBIAN
  [ -d "${DEB_ROOT}/sshupdated/DEBIAN" ] || mkdir -p ${DEB_ROOT}/sshupdated/DEBIAN
  # Copy specfiles/deb/sshupdated-control to DEB-ROOT/sshupdated/DEBIAN/control
  cp ${MYDIR}/specfiles/deb/${client_service_name}-control ${DEB_ROOT}/sshupdated/DEBIAN/control
  # Copy specfiles/deb/sshupdated-conffiles to DEB-ROOT/sshupdated/DEBIAN/conffiles
  cp ${MYDIR}/specfiles/deb/${client_service_name}-conffiles ${DEB_ROOT}/sshupdated/DEBIAN/conffiles
  # Post install
  cp -p ${MYDIR}/specfiles/deb/${client_service_name}-postinst ${DEB_ROOT}/sshupdated/DEBIAN/postinst
  # Pre rm
  cp -p ${MYDIR}/specfiles/deb/${client_service_name}-prerm ${DEB_ROOT}/sshupdated/DEBIAN/prerm
  # Create a working fakeroot/filestructure with files you want
  [ -d "${DEB_ROOT}/sshupdated/usr/sbin" ] || mkdir -p ${DEB_ROOT}/sshupdated/usr/sbin 
  [ -d "${DEB_ROOT}/sshupdated/etc/init.d" ] || mkdir -p ${DEB_ROOT}/sshupdated/etc/init.d
  [ -d "${DEB_ROOT}/sshupdated/etc/ssh" ] || mkdir -p ${DEB_ROOT}/sshupdated/etc/ssh
  [ -d "${DEB_ROOT}/sshupdated/usr/share/sshupdated" ] || mkdir -p ${DEB_ROOT}/sshupdated/usr/share/sshupdated
  [ -f "${deps}/common/sshd_config" ] && cp ${deps}/common/sshd_config ${DEB_ROOT}/sshupdated/etc/ssh/${client_service_name}.conf
  [ -f "${deps}/deb/startscript" ] && cp ${deps}/deb/startscript ${DEB_ROOT}/sshupdated/etc/init.d/${client_service_name}
  [ -f "${deps}/deb/wrapper.sh" ] && cp ${deps}/deb/wrapper.sh ${DEB_ROOT}/sshupdated/usr/share/sshupdated/wrapper.sh
  # If people want to include keys, fix this
  #[ -d "${DEB_ROOT}/sshupdate/root/.ssh" ] || mkdir -p ${DEB_ROOT}/sshupdate/root/.ssh
  #/root/.ssh/sshupdated_keys
  # Create Deb
  dpkg-deb --build DEB-ROOT/sshupdated
  # Show where deb is located DEB-ROOT/sshupdated.deb
  print_line "The new deb-package is found here: ${DEB_ROOT}/sshupdated.deb\n"
}

function f_create_server_package_deb {
  # Check if dpkg-deb exists
  [ -f "/usr/bin/dpkg-deb" ] || ( echo "No dpkg-deb existing, please install it so we can create deb's for you" ; exit 1 )
  # Create DEB_ROOT/sshupdate/DEBIAN
  [ -d "${DEB_ROOT}/sshupdate/DEBIAN" ] || mkdir -p ${DEB_ROOT}/sshupdate/DEBIAN
  # Copy specfiles/deb/sshupdate-control to DEB-ROOT/sshupdate/DEBIAN/control
  cp ${MYDIR}/specfiles/deb/${server_service_name}-control ${DEB_ROOT}/sshupdate/DEBIAN/control
  # Copy specfiles/deb/sshupdate-conffiles to DEB-ROOT/sshupdate/DEBIAN/conffiles
  cp ${MYDIR}/specfiles/deb/${server_service_name}-conffiles ${DEB_ROOT}/sshupdate/DEBIAN/conffiles
  # Create a working fakeroot/filestructure with files you want
  # Install config-file
  [ -d "${DEB_ROOT}/sshupdate/etc/sshupdate" ] || mkdir -p ${DEB_ROOT}/sshupdate/etc/sshupdate 
  [ -f "${DEB_ROOT}/sshupdate/etc/sshupdate/config" ] || touch ${DEB_ROOT}/sshupdate/etc/sshupdate/config
  # Insert sshupdate-script
  [ -d "${DEB_ROOT}/sshupdate/usr/sbin" ] || mkdir -p ${DEB_ROOT}/sshupdate/usr/sbin 
  [ -f "${deps}/common/sshupdate" ] && cp ${deps}/common/sshupdate ${DEB_ROOT}/sshupdate/usr/sbin/
  # Create Deb
  dpkg-deb --build DEB-ROOT/sshupdate
  # Show where deb is located DEB-ROOT/sshupdate.deb
  print_line "The new deb-package is found here: ${DEB_ROOT}/sshupdate.deb\n"
}

## EL6 functions

function f_create_sshd_config_el6 {
  DEST=${RPM_ROOT}/$1
  [ -d "${DEST}" ] || mkdir -p ${DEST}
  [ -f "${deps}/common/sshd_config" ] && sed -e "s/^Port.*/Port ${sshd_port}/g" -e "s/^AddressFamily.*/AddressFamily ${sshd_inet}/g" ${deps}/common/sshd_config > ${DEST}/${client_service_name}.conf
}

function f_create_sshd_startscripts_el6 {
  [ -d "${RPM_ROOT}/etc/rc.d/init.d" ] || mkdir -p ${RPM_ROOT}/etc/rc.d/init.d
  [ -f "${deps}/el6/startscript" ] && cp ${deps}/el6/startscript ${RPM_ROOT}/etc/rc.d/init.d/${client_service_name}
}

## EL6 functions

function f_create_sshd_config_el6 {
  DEST=${RPM_ROOT}/$1
  [ -d "${DEST}" ] || mkdir -p ${DEST}
  [ -f "${deps}/common/sshd_config" ] && sed -e "s/^Port.*/Port ${sshd_port}/g" -e "s/^AddressFamily.*/AddressFamily ${sshd_inet}/g" ${deps}/common/sshd_config > ${DEST}/${client_service_name}.conf
}

function f_create_sshd_startscripts_el6 {
  [ -d "${RPM_ROOT}/etc/rc.d/init.d" ] || mkdir -p ${RPM_ROOT}/etc/rc.d/init.d
  [ -f "${deps}/el6/startscript" ] && cp ${deps}/el6/startscript ${RPM_ROOT}/etc/rc.d/init.d/${client_service_name}
}

function f_gen_gpg_signing_keys {
	# WARNING This is painfully slow on virtual machines.
	if [ ! -d "$MYDIR/keys/gpg" ]; then
		mkdir -p $MYDIR/keys/gpg
	fi
	if [ -f "$MYDIR/keys/gpg/$GPG_PUBRING.sec" -a -f "$MYDIR/keys/gpg/$GPG_SECRING.pub" ]; then
		echo "GPG keys already generated. skipping."
	else
		echo "Creating GPG signing keys." 
		echo "This is painfully slow on virtual machines due to low entropy."
		echo "See gpg.txt for alternatives."
		printf "Generate pgpkeys for signing?(y/N): "
		read ANSWER
		if [[ "$ANSWER" =~ 'y|Y|Yes|yes|YES' ]]; then
			gpg --batch --gen-key<<EOF
%echo Generating a pgp keys for signing packages. 
%echo Don't worry. you can re-sign it later if you wish.
Key-Type: $GPG_KEY
Key-Length: $GPG_KEYSIZE
Subkey-type: $GPG_SUBKEY
Subkey-Length: $GPG_SUBKEYSIZE
Name-Real: $GPG_NAME
Name-Email: $GPG_EMAIL
Name-Comment: $GPG_COMMENT
%no-protection
%transient-key
%pubring ${GPG_PUBRING}.pub
%secring ${GPG_SECRING}.sec
%commit 
%echo done creating keys
EOF
		else
			echo "skipping gpg key generation. See gpg.txt for alternatives"
		fi
	fi
}

function f_sign_rpm {
	# check for sane rpm macros.
	echo "Checking for proper entries in ~/.rpmmacros"
	egrep '%_signature gpg' ~/.rpmmacros > /dev/null
	if [ $? -eq 1 ]; then
		echo "%_signature gpg" >> ~/.rpmmacros
		echo "%_gpg_name sshupdate" >> ~/.rpmmacros
		echo "%_gpg_path ~/sshupdate/keys/gpg"
	else
		echo "Already have %_signature gpg present in ~/.rpmmacros. "
		echo "assuming happily that all stuff there is correct"
	
	fi
	rpm --addsign $1 
	echo "if you wish to resign this package with another key, simply use the"
	echo "\"rpm --addsign\" command."
}


function f_create_sshd_authkeys_el6 {
  mkdir -p ${RPM_ROOT}/root/.ssh/
  [ -f "${RPM_ROOT}/root/.ssh/${client_service_name}_keys" ] && rm ${RPM_ROOT}/root/.ssh/${client_service_name}_keys
  for key in $keys; do
    tmpkey=`cat ${MYDIR}/keys/${key}.pub`
    echo "command=\"/usr/share/${client_service_name}/wrapper.sh\",no-port-forwarding,no-X11-forwarding,no-pty ${tmpkey}" >> ${RPM_ROOT}/root/.ssh/${client_service_name}_keys
  done
}

function f_build_server_rpm_el6  {
  mkdir -p ${MYDIR}/rpmbuild/server/{BUILD,RPMS,SOURCES,SPECS,SRPMS}
  mkdir -p ${MYDIR}/tmp/${server_service_name}-${version}
  cd ${RPM_ROOT}
  cp -r * ${MYDIR}/tmp/${server_service_name}-${version}
  cd ${MYDIR}/tmp 
  tar zcf ${MYDIR}/rpmbuild/server/SOURCES/${server_service_name}-${version}.tar.gz . 
  print_line "\nBuilding RPM based on scripts:"
  if [ ! -f $RPMBUILD ]; then
    echo "No rpmbuild installed. exiting. ($RPMBUILD)"
    echo "try yum install rpm-build"
    exit 1
  fi
  rpmbuild -bb ${MYDIR}/specfiles/el6/${server_service_name}.specfile --define "_topdir ${MYDIR}/rpmbuild/server" > /dev/null 2>&1
  print_success $?
  echo -e "Server RPM available in: ${MYDIR}/rpmbuild/server/RPMS/noarch/${server_service_name}-${version}-1.noarch.rpm"
}

function f_build_client_rpm_el6  {
  mkdir -p ${MYDIR}/rpmbuild/client/{BUILD,RPMS,SOURCES,SPECS,SRPMS}
  mkdir -p ${MYDIR}/tmp/${client_service_name}-${version}
  cd ${RPM_ROOT}
  cp -r * ${MYDIR}/tmp/${client_service_name}-${version}
  cd ${MYDIR}/tmp 
  tar zcf ${MYDIR}/rpmbuild/client/SOURCES/${client_service_name}-${version}.tar.gz . 
  print_line "\nBuilding RPM based on scripts:"
  if [ ! -f $RPMBUILD ]; then
    echo "No rpmbuild installed. exiting. ($RPMBUILD)"
    echo "try yum install rpm-build"
    exit 1
  fi
  rpmbuild -bb ${MYDIR}/specfiles/el6/${client_service_name}.specfile --define "_topdir ${MYDIR}/rpmbuild/client" > /dev/null 2>&1
  print_success $?
  echo -e "Client RPM available in: ${MYDIR}/rpmbuild/client/RPMS/noarch/${client_service_name}-${version}-1.noarch.rpm"
}

function f_create_sshupdate_filestructure_el6 {
  # Create directories
  [ -d "${RPM_ROOT}/etc/sshupdate" ] || mkdir -p ${RPM_ROOT}/etc/sshupdate
  [ -d "${RPM_ROOT}/usr/sbin" ] || mkdir -p ${RPM_ROOT}/usr/sbin
  # Install sshupdate
  [ -f "${deps}/common/sshupdate" ] && cp ${deps}/common/sshupdate ${RPM_ROOT}/usr/sbin/sshupdate
  # Just a placeholder, empty config-file
  [ -f "${RPM_ROOT}/etc/sshupdate/config" ] || touch ${RPM_ROOT}/etc/sshupdate/config
}

function f_create_server_package_el6 {
  [ -d ${RPM_ROOT} ] && rm -rf ${RPM_ROOT}
  mkdir -p ${RPM_ROOT}
  f_create_sshupdate_filestructure_el6
  f_build_server_rpm_el6 ${pkgs}/${server_service_name}-el6/${server_service_name}.spec
}

function f_create_client_package_el6 {
  [ -d ${RPM_ROOT} ] && rm -rf ${RPM_ROOT}
  mkdir -p ${RPM_ROOT}
  f_create_sshd_config_el6 etc/ssh
  f_create_sshd_startscripts_el6
  f_populate_scripts 
  f_create_sshd_authkeys_el6
  f_build_client_rpm_el6 ${pkgs}/${client_service_name}-el6/${client_service_name}.spec
}

function f_help {
PROG=$(basename $0)
  cat << EOF
$PROG options:
	$PROG gen-keys - Generate ssh-keys
	$PROG build-deb - Create deb's
	$PROG build-client-deb - Create client deb
	$PROG build-server-deb - Create server deb
	$PROG build-rpm - Create rpm's
	$PROG build-client-rpm - Create client rpm
	$PROG build-server-rpm - Create server rpm
	$PROG clean - Clean failed build
	$PROG init - Run gen-keys, then build-rpm
	$PROG sign-client-rpm - Sign the rpm with a gpg-key. see gpg.txt

Note: $PROG uses relative paths.
EOF
}

### Main
case "$1" in 
  gen-keys)
    f_genkeys
    #still needs some work
    #f_gen_gpg_signing_keys
  ;;
  build-deb)
    f_create_client_package_deb
    f_create_server_package_deb
  ;;
  build-client-deb)
    f_create_client_package_deb
  ;;
  build-server-deb)
    f_create_server_package_deb
  ;;
  build-deb)
    f_create_client_package_deb
    f_create_server_package_deb
  ;;
  build-client-deb)
    f_create_client_package_deb
  ;;
  build-server-deb)
    f_create_server_package_deb
  ;;
  build-rpm)
    f_create_client_package_el6
    f_create_server_package_el6
  ;;
  build-client-rpm)
    f_create_client_package_el6
  ;;
  sign-client-rpm)
    f_sign_rpm ~/sshupdate/rpmbuild/client/RPMS/noarch/sshupdated-0.1-1.noarch.rpm
  ;;
  build-server-rpm)
    f_create_server_package_el6
  ;;
  clean)
    rm -rf /var/tmp/${client_service_name}-root/
  ;;
  init)
    print_line "\n sshupdate - Patch Management over SSH\n"
    print_line "\nTo make sshupdate work it requires a node to be used as\n"
    print_line "a manager. By answering the following questions we will\n"
    print_line "guide you through the process of creating packages that\n"
    print_line "can be installed both on managers and clients that you\n"
    print_line "wish to control.\n\n"
    print_line "For additional information see:\n"
    print_line "https://github.com/trams242/sshupdate\n\n"
    print_line "The manager uses SSH-keys to communicate with each client\n"
    print_line "to make this work, we need to have some keys.\n\n"
    f_query_user "Do you already have keys generated that you'd like to use?" yes_no
    if [ "$?" = "0" ]
    then
      f_query_user "\nWhere are they located?" check_file
    else
      print_line "\nLet's generate you some keys.\n"
      f_genkeys
    fi
    if [ -f /etc/redhat-release ]
    then
      f_query_user "\nDo you want to create a client package?" yes_no
      [ $? = 0 ] && f_create_client_package_el6
      f_query_user "\nDo you want to create a server package?" yes_no
      [ $? = 0 ] && f_create_server_package_el6
    elif [ -f /etc/debian_version ]
    then
      f_query_user "\nDo you want to create a client package?" yes_no
      [ $? = 0 ] && f_create_client_package_deb
      f_query_user "\nDo you want to create a server package?" yes_no
      [ $? = 0 ] && f_create_server_package_deb
    else
      echo "Im not sure which distribution you want to build packages for, skipping."
    fi
  ;;
  *)
    f_help
  ;;
esac
