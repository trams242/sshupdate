#!/bin/bash
# Description:
# This script will setup your server with sshupdated. It offers you a way to create required package to spread to your clients in the same time.
# It generates the SSH-keys used in the different scripts.

### Variables
version=0.1

# ? What is this used for? Or well, intended to be used for
keys="sshupdated" 

# Which type of SSH-key do we want to use
keytype="rsa"

# What size should the key be
keysize=4096

# Which port do we want to run the server on
sshd_port=2222

# Where should we listen? Default: any ( any / inet6 )
sshd_inet="any"

# What do we call the service
# Please remember, the server does not run a daemon, only the client does that
server_service_name="sshupdate"
client_service_name="sshupdated"

# GPG STUFF
GPG_KEY=RSA
GPG_KEYSIZE=4096
GPG_SUBKEY=RSA
GPG_SUBKEYSIZE=4096
GPG_NAME="sshupdated signing key"
GPG_COMMENT="Autogenerated sshupdate signing key"
GPG_EMAIL="sshupdated@example.com"
GPG_EXPIRE="20161010T000000" #XXX FIXME
GPG_SECRING=$server_service_name
GPG_PUBRING=$server_service_name

# Figure out $MYDIR
MYDIR=$(dirname $0)
if [ "${MYDIR}" = "." ]
then
  MYDIR=$(pwd)
fi

# Where should we build the RPM
RPM_ROOT=${MYDIR}/RPM-ROOT

# Where should we build the DEB
DEB_ROOT=${MYDIR}/DEB-ROOT

# Debian Revision
DEB_REV=1

# Debian Architechture 
DEB_ARCH=all

# Where should we build the DEB
SUSE_ROOT=${MYDIR}/SUSE-ROOT

# Where do we find the deps-directory
deps=${MYDIR}/deps

# Where is the pkgs directory found
pkgs=${MYDIR}/pkgs

### Sanity is good
# Making sure we have a sane path
PATH=/sbin:/usr/sbin:/bin:/usr/bin

RPMBUILD=/usr/bin/rpmbuild
TPUT=/usr/bin/tput

# Some variables needed for fancy output
COLS=$($TPUT cols)
COL=$(($COLS-8))
UP=$($TPUT cuu1)
START=$($TPUT hpa 0)
END=$($TPUT hpa $COL)
RED=$($TPUT setaf 1)
GREEN=$($TPUT setaf 2)
NORMAL=$($TPUT op)

### Functions

## General functions

# To be used to print success on a previous command, like so: print_success $?
function print_success {
  if [ $1 -eq 0 ]
  then
    STATUS="${GREEN}ok"
  else
    STATUS="${RED}fail"
  fi
  if [ ! -z "$2" ]
  then
    REASON=$2
    /bin/echo -e " [ ${STATUS}${NORMAL} ]\n  Reason: $REASON"
  else
    /bin/echo -e " [ ${STATUS}${NORMAL} ]"
  fi
}

# Used in conjunction with print_success
function print_line {
  if [ -z "$1" ]
  then
    echo
  else
    echo -en $@
  fi
}

function f_query_user {
  while true
  do
    if [ "$2" = "yes_no" ]
    then
      echo -e "$1 [y/n]"
    else
      echo -e "$1"
    fi
    echo -n "Answer: "
    read QUERY_ANSWER
    if [ "$2" = "check_file" ] || [ "$2" = "check_dir" ]
    then
      [ -e "$QUERY_ANSWER" ] && break
    elif [ "$2" = "yes_no" ]
    then
      if [[ "$QUERY_ANSWER" =~ ^[yY]*[eE]*[sS]*$ ]]
      then
        return 0
        break
      elif [[ "$QUERY_ANSWER" =~ ^[nN]*[oO]*$ ]]
      then
        return 1
        break
      fi
    else
      [ ! -z "$QUERY_ANSWER" ] && break
    fi
  done
}


function f_genkeys {
  print_line "Generating keys"
  for key in $keys; do
    if [ ! -f ${MYDIR}/keys/$key ]; then
      umask 077
      mkdir -p ${MYDIR}/keys	
      ssh-keygen -t $keytype -b ${keysize} -f ${MYDIR}/keys/${key} -N ""
      print_success $?
    else
      print_success $? "${client_service_name}-key already exist (${MYDIR}/keys/${key})"
    fi
  done
}

function f_populate_scripts {
  # Make sure directory exists
  [ -d "${RPM_ROOT}/usr/share/${client_service_name}" ] || mkdir -p ${RPM_ROOT}/usr/share/${client_service_name}
  # Install wrapper.sh
  [ -f "${deps}/el6/wrapper.sh" ] && cp ${deps}/el6/wrapper.sh ${RPM_ROOT}/usr/share/${client_service_name}
}

## Deb functions

function f_create_client_package_deb {
  DEB_ROOT=${DEB_ROOT}/${client_service_name}
  rm -rf ${DEB_ROOT}
  [ -d ${DEB_ROOT} ] || mkdir -p ${DEB_ROOT}
  # Check if dpkg-deb exists
  [ -f "/usr/bin/dpkg-deb" ] || ( echo "No dpkg-deb existing, please install it so we can create deb's for you" ; exit 1 )
  # Create DEB-ROOT/sshupdated/DEBIAN
  [ -d "${DEB_ROOT}/DEBIAN" ] || mkdir -m 755 -p ${DEB_ROOT}/DEBIAN
  # Copy specfiles/deb/sshupdated-control to DEB-ROOT/sshupdated/DEBIAN/control
  cp ${MYDIR}/specfiles/deb/${client_service_name}-control ${DEB_ROOT}/DEBIAN/control
  # Copy specfiles/deb/sshupdated-conffiles to DEB-ROOT/sshupdated/DEBIAN/conffiles
  cp ${MYDIR}/specfiles/deb/${client_service_name}-conffiles ${DEB_ROOT}/DEBIAN/conffiles
  # Post install
  cp -p ${MYDIR}/specfiles/deb/${client_service_name}-postinst ${DEB_ROOT}/DEBIAN/postinst
  # Pre rm
  cp -p ${MYDIR}/specfiles/deb/${client_service_name}-prerm ${DEB_ROOT}/DEBIAN/prerm
  # Create a working fakeroot/filestructure with files you want
  [ -d "${DEB_ROOT}/etc/init.d" ] || mkdir -p ${DEB_ROOT}//etc/init.d
  [ -d "${DEB_ROOT}/etc/ssh" ] || mkdir -p ${DEB_ROOT}/etc/ssh
  [ -d "${DEB_ROOT}/usr/share/${client_service_name}" ] || mkdir -p ${DEB_ROOT}/usr/share/${client_service_name}
  [ -f "${deps}/common/sshd_config" ] && cp ${deps}/common/sshd_config ${DEB_ROOT}/etc/ssh/${client_service_name}.conf
  [ -f "${deps}/deb/startscript" ] && cp ${deps}/deb/startscript ${DEB_ROOT}/etc/init.d/${client_service_name}
  [ -f "${deps}/deb/wrapper.sh" ] && cp ${deps}/deb/wrapper.sh ${DEB_ROOT}/usr/share/${client_service_name}/wrapper.sh
  [ -d "${DEB_ROOT}/root/.ssh" ] || mkdir -p ${DEB_ROOT}/root/.ssh
  if [ -f "${MYDIR}/keys/${client_service_name}.pub" ]
  then
    for key in $keys; do
      tmpkey=`cat ${MYDIR}/keys/${key}.pub`
      echo "command=\"/usr/share/${client_service_name}/wrapper.sh\",no-port-forwarding,no-X11-forwarding,no-pty ${tmpkey}" >> ${DEB_ROOT}/root/.ssh/${client_service_name}_keys
    done
  fi
  # Create Deb
  dpkg-deb --build ${DEB_ROOT}
  # Move deb-file and change its name
  [ -d ${MYDIR}/packages ] || mkdir -p ${MYDIR}/packages
  mv ${DEB_ROOT}.deb ${MYDIR}/packages/${DEB_ROOT}_${version}-${DEB_REV}_${DEB_ARCH}.deb
  # Remove dir
  rm -rf ${DEB_ROOT}
  # Show where deb is located DEB-ROOT/sshupdated.deb
  print_line "The new deb-package is found here: ${MYDIR}/packages/${DEB_ROOT}_${version}-${DEB_REV}_${DEB_ARCH}.deb\n"
}

function f_create_server_package_deb {
  DEB_ROOT=${DEB_ROOT}/${server_service_name}
  rm -rf ${DEB_ROOT}
  [ -d ${DEB_ROOT} ] || mkdir -p ${DEB_ROOT}
  # Check if dpkg-deb exists
  [ -f "/usr/bin/dpkg-deb" ] || ( echo "No dpkg-deb existing, please install it so we can create deb's for you" ; exit 1 )
  # Create DEB_ROOT/${server_service_name}/DEBIAN
  [ -d "${DEB_ROOT}/DEBIAN" ] || mkdir -m 755 -p ${DEB_ROOT}/DEBIAN
  # Copy specfiles/deb/sshupdate-control to DEB-ROOT/sshupdate/DEBIAN/control
  cp ${MYDIR}/specfiles/deb/${server_service_name}-control ${DEB_ROOT}/DEBIAN/control
  # Copy specfiles/deb/sshupdate-conffiles to DEB-ROOT/sshupdate/DEBIAN/conffiles
  cp ${MYDIR}/specfiles/deb/${server_service_name}-conffiles ${DEB_ROOT}/DEBIAN/conffiles
  # Create a working fakeroot/filestructure with files you want
  # Install config-file
  [ -d "${DEB_ROOT}/etc/${server_service_name}" ] || mkdir -p ${DEB_ROOT}/etc/${server_service_name} 
  [ -f "${DEB_ROOT}/etc/${server_service_name}/config" ] || touch ${DEB_ROOT}/etc/${server_service_name}/config
  # Insert sshupdate-script
  [ -d "${DEB_ROOT}/usr/sbin" ] || mkdir -p ${DEB_ROOT}/usr/sbin 
  [ -f "${deps}/common/${server_service_name}" ] && cp ${deps}/common/${server_service_name} ${DEB_ROOT}/usr/sbin/
  # Create Deb
  dpkg-deb --build DEB-ROOT/${server_service_name}
  # Move deb-file and change its name
  [ -d ${MYDIR}/packages ] || mkdir -p ${MYDIR}/packages
  mv ${DEB_ROOT}.deb ${MYDIR}/packages/${DEB_ROOT}_${version}-${DEB_REV}_${DEB_ARCH}.deb
  # If people want to include keys, fix this
  # Remove dir
  rm -rf ${DEB_ROOT}
  # Show where deb is located DEB-ROOT/${server_service_name}.deb
  print_line "The new deb-package is found here: ${MYDIR}/packages/${DEB_ROOT}_${version}-${DEB_REV}_${DEB_ARCH}.deb\n"
}

## EL6 functions

function f_create_sshd_config_el6 {
  DEST=${RPM_ROOT}/$1
  [ -d "${DEST}" ] || mkdir -p ${DEST}
  [ -f "${deps}/common/sshd_config" ] && sed -e "s/^Port.*/Port ${sshd_port}/g" -e "s/^AddressFamily.*/AddressFamily ${sshd_inet}/g" ${deps}/common/sshd_config > ${DEST}/${client_service_name}.conf
}

function f_create_sshd_startscripts_el6 {
  [ -d "${RPM_ROOT}/etc/rc.d/init.d" ] || mkdir -p ${RPM_ROOT}/etc/rc.d/init.d
  [ -f "${deps}/el6/startscript" ] && cp ${deps}/el6/startscript ${RPM_ROOT}/etc/rc.d/init.d/${client_service_name}
}

## EL6 functions

function f_create_sshd_config_el6 {
  DEST=${RPM_ROOT}/$1
  [ -d "${DEST}" ] || mkdir -p ${DEST}
  [ -f "${deps}/common/sshd_config" ] && sed -e "s/^Port.*/Port ${sshd_port}/g" -e "s/^AddressFamily.*/AddressFamily ${sshd_inet}/g" ${deps}/common/sshd_config > ${DEST}/${client_service_name}.conf
}

function f_create_sshd_startscripts_el6 {
  [ -d "${RPM_ROOT}/etc/rc.d/init.d" ] || mkdir -p ${RPM_ROOT}/etc/rc.d/init.d
  [ -f "${deps}/el6/startscript" ] && cp ${deps}/el6/startscript ${RPM_ROOT}/etc/rc.d/init.d/${client_service_name}
}

function f_gen_gpg_signing_keys {
  # WARNING This is painfully slow on virtual machines.
  if [ ! -d "$MYDIR/keys/gpg" ]; then
    mkdir -p $MYDIR/keys/gpg
  fi
  if [ -f "$MYDIR/keys/gpg/$GPG_PUBRING.sec" -a -f "$MYDIR/keys/gpg/$GPG_SECRING.pub" ]; then
    echo "GPG keys already generated. skipping."
  else
    echo "Creating GPG signing keys." 
    echo "This is painfully slow on virtual machines due to low entropy."
    echo "See gpg.txt for alternatives."
    printf "Generate pgpkeys for signing?(y/N): "
    read ANSWER
    if [[ "$ANSWER" =~ 'y|Y|Yes|yes|YES' ]]; then
      gpg --batch --gen-key<<EOF
%echo Generating a pgp keys for signing packages. 
%echo Don't worry. you can re-sign it later if you wish.
Key-Type: $GPG_KEY
Key-Length: $GPG_KEYSIZE
Subkey-type: $GPG_SUBKEY
Subkey-Length: $GPG_SUBKEYSIZE
Name-Real: $GPG_NAME
Name-Email: $GPG_EMAIL
Name-Comment: $GPG_COMMENT
%no-protection
%transient-key
%pubring ${GPG_PUBRING}.pub
%secring ${GPG_SECRING}.sec
%commit 
%echo done creating keys
EOF
    else
      echo "skipping gpg key generation. See gpg.txt for alternatives"
    fi
  fi
}

function f_sign_rpm {
  # check for sane rpm macros.
  echo "Checking for proper entries in ~/.rpmmacros"
  egrep '%_signature gpg' ~/.rpmmacros > /dev/null
  if [ $? -eq 1 ]; then
    echo "%_signature gpg" >> ~/.rpmmacros
    echo "%_gpg_name sshupdate" >> ~/.rpmmacros
    echo "%_gpg_path ~/sshupdate/keys/gpg"
  else
    echo "Already have %_signature gpg present in ~/.rpmmacros. "
    echo "assuming happily that all stuff there is correct"
  fi
  rpm --addsign $1 
  echo "if you wish to resign this package with another key, simply use the"
  echo "\"rpm --addsign\" command."
}


function f_create_sshd_authkeys_el6 {
  mkdir -p ${RPM_ROOT}/root/.ssh/
  [ -f "${RPM_ROOT}/root/.ssh/${client_service_name}_keys" ] && rm ${RPM_ROOT}/root/.ssh/${client_service_name}_keys
  for key in $keys; do
    tmpkey=`cat ${MYDIR}/keys/${key}.pub`
    echo "command=\"/usr/share/${client_service_name}/wrapper.sh\",no-port-forwarding,no-X11-forwarding,no-pty ${tmpkey}" >> ${RPM_ROOT}/root/.ssh/${client_service_name}_keys
  done
}

function f_build_server_rpm_el6  {
  mkdir -p ${MYDIR}/rpmbuild/server/{BUILD,RPMS,SOURCES,SPECS,SRPMS}
  mkdir -p ${MYDIR}/tmp/${server_service_name}-${version}
  cd ${RPM_ROOT}
  cp -r * ${MYDIR}/tmp/${server_service_name}-${version}
  cd ${MYDIR}/tmp 
  tar zcf ${MYDIR}/rpmbuild/server/SOURCES/${server_service_name}-${version}.tar.gz . 
  print_line "\nBuilding RPM based on scripts:"
  if [ ! -f $RPMBUILD ]; then
    echo "No rpmbuild installed. exiting. ($RPMBUILD)"
    echo "try yum install rpm-build"
    exit 1
  fi
  rpmbuild -bb ${MYDIR}/specfiles/el6/${server_service_name}.specfile --define "_topdir ${MYDIR}/rpmbuild/server" > /dev/null 2>&1
  print_success $?
  [ -d ${MYDIR}/packages ] || mkdir -p ${MYDIR}/packages
  if [ -f ${MYDIR}/rpmbuild/server/RPMS/noarch/${server_service_name}-${version}-1.noarch.rpm ]
  then
    mv ${MYDIR}/rpmbuild/server/RPMS/noarch/${server_service_name}-${version}-1.noarch.rpm ${MYDIR}/packages/${server_service_name}-${version}-1.noarch.rpm
    rm -rf ${RPM_ROOT} ${MYDIR}/tmp ${MYDIR}/rpmbuild
    echo -e "Server RPM available in: ${MYDIR}/packages/${server_service_name}-${version}-1.noarch.rpm"
  else
    echo -e "Build failed, saving ${RPM_ROOT}. Will remove when starting next build."
    exit 1
  fi
}

function f_build_client_rpm_el6  {
  mkdir -p ${MYDIR}/rpmbuild/client/{BUILD,RPMS,SOURCES,SPECS,SRPMS}
  mkdir -p ${MYDIR}/tmp/${client_service_name}-${version}
  cd ${RPM_ROOT}
  cp -r * ${MYDIR}/tmp/${client_service_name}-${version}
  cd ${MYDIR}/tmp 
  tar zcf ${MYDIR}/rpmbuild/client/SOURCES/${client_service_name}-${version}.tar.gz . 
  print_line "\nBuilding RPM based on scripts:"
  if [ ! -f $RPMBUILD ]; then
    echo "No rpmbuild installed. exiting. ($RPMBUILD)"
    echo "try yum install rpm-build"
    exit 1
  fi
  rpmbuild -bb ${MYDIR}/specfiles/el6/${client_service_name}.specfile --define "_topdir ${MYDIR}/rpmbuild/client" > /dev/null 2>&1
  print_success $?
  [ -d ${MYDIR}/packages ] || mkdir -p ${MYDIR}/packages
  if [ -f ${MYDIR}/rpmbuild/client/RPMS/noarch/${client_service_name}-${version}-1.noarch.rpm ]
  then
    mv ${MYDIR}/rpmbuild/client/RPMS/noarch/${client_service_name}-${version}-1.noarch.rpm ${MYDIR}/packages/${client_service_name}-${version}-1.noarch.rpm
    rm -rf ${RPM_ROOT} ${MYDIR}/tmp ${MYDIR}/rpmbuild
    echo -e "Client RPM available in: ${MYDIR}/packages/${client_service_name}-${version}-1.noarch.rpm"
  else
    echo -e "Build failed, saving ${RPM_ROOT}. Will remove when starting next build."
    exit 1
  fi
}

function f_create_sshupdate_filestructure_el6 {
  # Create directories
  [ -d "${RPM_ROOT}/etc/sshupdate" ] || mkdir -p ${RPM_ROOT}/etc/sshupdate
  [ -d "${RPM_ROOT}/usr/sbin" ] || mkdir -p ${RPM_ROOT}/usr/sbin
  # Install sshupdate
  [ -f "${deps}/common/sshupdate" ] && cp ${deps}/common/sshupdate ${RPM_ROOT}/usr/sbin/sshupdate
  # Just a placeholder, empty config-file
  [ -f "${RPM_ROOT}/etc/sshupdate/config" ] || touch ${RPM_ROOT}/etc/sshupdate/config
}

function f_create_server_package_el6 {
  [ -d ${RPM_ROOT} ] && rm -rf ${RPM_ROOT}
  mkdir -p ${RPM_ROOT}
  f_create_sshupdate_filestructure_el6
  f_build_server_rpm_el6 ${pkgs}/${server_service_name}-el6/${server_service_name}.spec
}

function f_create_client_package_el6 {
  [ -d ${RPM_ROOT} ] && rm -rf ${RPM_ROOT}
  mkdir -p ${RPM_ROOT}
  f_create_sshd_config_el6 etc/ssh
  f_create_sshd_startscripts_el6
  f_populate_scripts 
  f_create_sshd_authkeys_el6
  f_build_client_rpm_el6 ${pkgs}/${client_service_name}-el6/${client_service_name}.spec
}

## Suse functions
function f_create_client_package_suse {
  SUSE_ROOT=${SUSE_ROOT}/${client_service_name}
  rm -rf ${SUSE_ROOT}
  [ -d ${SUSE_ROOT} ] || mkdir -p ${SUSE_ROOT}
  [ -d /var/tmp/${client_service_name}-root ] && rm -rf /var/tmp/${client_service_name}-root
  # Make sure common-files exist
  [ -d ${SUSE_ROOT}/etc/ssh ] || mkdir -p ${SUSE_ROOT}/etc/ssh
  [ -f ${deps}/common/sshd_config ] && sed -e "s/^Port.*/Port ${sshd_port}/g" -e "s/^AddressFamily.*/AddressFamily ${sshd_inet}/g" ${deps}/common/sshd_config > ${SUSE_ROOT}/etc/ssh/${client_service_name}.conf
  # Make sure dist-specific files exist
  [ -d "${SUSE_ROOT}/etc/init.d" ] || mkdir -p ${SUSE_ROOT}/etc/init.d
  [ -f "${deps}/suse/startscript" ] && cp ${deps}/suse/startscript ${SUSE_ROOT}/etc/init.d/${client_service_name}
  [ -d "${SUSE_ROOT}/usr/share/${client_service_name}" ] || mkdir -p ${SUSE_ROOT}/usr/share/${client_service_name}
  [ -f "${deps}/suse/wrapper.sh" ] && cp ${deps}/suse/wrapper.sh ${SUSE_ROOT}/usr/share/${client_service_name}
  [ -d "${SUSE_ROOT}/root/.ssh" ] || mkdir -p ${SUSE_ROOT}/root/.ssh
  if [ -f "${MYDIR}/keys/${client_service_name}.pub" ]
  then
    for key in $keys; do
      tmpkey=`cat ${MYDIR}/keys/${key}.pub`
      echo "command=\"/usr/share/${client_service_name}/wrapper.sh\",no-port-forwarding,no-X11-forwarding,no-pty ${tmpkey}" >> ${SUSE_ROOT}/root/.ssh/${client_service_name}_keys
    done
  fi
  # Create the actual RPM
  mkdir -p ${SUSE_ROOT}/{BUILD,RPMS,SOURCES,SPECS,SRPMS}
  mkdir -p ${SUSE_ROOT}/${client_service_name}-${version}
  cd ${SUSE_ROOT}
  for i in $(ls | grep -v ${client_service_name}-${version}) ; do mv $i ${SUSE_ROOT}/${client_service_name}-${version}/ ; done
  tar zcf ${SUSE_ROOT}/${client_service_name}-${version}/SOURCES/${client_service_name}-${version}.tar.gz .
  print_line "\nBuilding RPM based on scripts:"
  if [ ! -f $RPMBUILD ]; then
    echo "No rpmbuild installed. exiting. ($RPMBUILD)"
    echo "try yum install rpm-build"
    exit 1
  fi
  rpmbuild -bb ${MYDIR}/specfiles/suse/${client_service_name}.specfile --define "_topdir ${SUSE_ROOT}/${client_service_name}-${version}" > /dev/null 2>&1
  print_success $?
  [ -d ${MYDIR}/packages ] || mkdir -p ${MYDIR}/packages
  if [ -f ${SUSE_ROOT}/${client_service_name}-${version}/RPMS/noarch/${client_service_name}-${version}-1.noarch.rpm ]
  then
    mv ${SUSE_ROOT}/${client_service_name}-${version}/RPMS/noarch/${client_service_name}-${version}-1.noarch.rpm ${MYDIR}/packages
    rm -rf ${SUSE_ROOT}
    echo -e "Client RPM available in: ${MYDIR}/packages/${client_service_name}-${version}-1.noarch.rpm"
  else
    echo -e "Build failed, saving ${SUSE_ROOT}. Will remove when starting next build."
    exit 1
  fi 
}

function f_create_server_package_suse {
  SUSE_ROOT=${SUSE_ROOT}/${server_service_name}
  rm -rf ${SUSE_ROOT}
  [ -d ${SUSE_ROOT} ] || mkdir -p ${SUSE_ROOT}
  [ -d /var/tmp/${server_service_name}-root ] && rm -rf /var/tmp/${server_service_name}-root
  # Create directories
  [ -d "${SUSE_ROOT}/etc/sshupdate" ] || mkdir -p ${SUSE_ROOT}/etc/sshupdate
  [ -d "${SUSE_ROOT}/usr/sbin" ] || mkdir -p ${SUSE_ROOT}/usr/sbin
  # Install sshupdate
  [ -f "${deps}/common/sshupdate" ] && cp ${deps}/common/sshupdate ${SUSE_ROOT}/usr/sbin/sshupdate
  # Just a placeholder, empty config-file
  [ -f "${SUSE_ROOT}/etc/sshupdate/config" ] || touch ${SUSE_ROOT}/etc/sshupdate/config
  # Create the actual RPM
  mkdir -p ${SUSE_ROOT}/{BUILD,RPMS,SOURCES,SPECS,SRPMS}
  mkdir -p ${SUSE_ROOT}/${server_service_name}-${version}
  cd ${SUSE_ROOT}
  for i in $(ls | grep -v ${server_service_name}-${version}) ; do mv $i ${SUSE_ROOT}/${server_service_name}-${version}/ ; done
  tar zcf ${SUSE_ROOT}/${server_service_name}-${version}/SOURCES/${server_service_name}-${version}.tar.gz .
  print_line "\nBuilding RPM based on scripts:"
  if [ ! -f $RPMBUILD ]; then
    echo "No rpmbuild installed. exiting. ($RPMBUILD)"
    echo "try yum install rpm-build"
    exit 1
  fi
  rpmbuild -bb ${MYDIR}/specfiles/suse/${server_service_name}.specfile --define "_topdir ${SUSE_ROOT}/${server_service_name}-${version}" > /dev/null 2>&1
  print_success $?
  [ -d ${MYDIR}/packages ] || mkdir -p ${MYDIR}/packages
  if [ -f ${SUSE_ROOT}/${server_service_name}-${version}/RPMS/noarch/${server_service_name}-${version}-1.noarch.rpm ]
  then
    mv ${SUSE_ROOT}/${server_service_name}-${version}/RPMS/noarch/${server_service_name}-${version}-1.noarch.rpm ${MYDIR}/packages
    rm -rf ${SUSE_ROOT}
    echo -e "Server RPM available in: ${MYDIR}/packages/${server_service_name}-${version}-1.noarch.rpm"
  else
    echo -e "Build failed, saving ${SUSE_ROOT}. Will remove when starting next build."
    exit 1
  fi 
}

## General functions 

function f_help {
PROG=$(basename $0)
  cat << EOF
$PROG options:
  $PROG gen-keys - Generate ssh-keys
  $PROG build-deb - Create packages for deb
  $PROG build-client-deb - Create client package for deb
  $PROG build-server-deb - Create server package for deb
  $PROG build-el6 - Create packages for el6/fedora
  $PROG build-client-el6 - Create client package for el6/fedora
  $PROG build-server-el6 - Create server package for el6/fedora
  $PROG build-suse - Create packages for suse
  $PROG build-client-suse - Create client package for suse
  $PROG build-server-suse - Create server package for suse
  $PROG clean - Clean failed build
  $PROG init - Run gen-keys, then build-rpm
  $PROG sign-client-rpm - Sign the rpm with a gpg-key. see gpg.txt

Note: $PROG uses relative paths.
EOF
}

### Main
case "$1" in 
  gen-keys)
    f_genkeys
    #still needs some work
    #f_gen_gpg_signing_keys
  ;;
  build-deb)
    f_create_client_package_deb
    f_create_server_package_deb
  ;;
  build-client-deb)
    f_create_client_package_deb
  ;;
  build-server-deb)
    f_create_server_package_deb
  ;;
  build-deb)
    f_create_client_package_deb
    f_create_server_package_deb
  ;;
  build-client-deb)
    f_create_client_package_deb
  ;;
  build-server-deb)
    f_create_server_package_deb
  ;;
  build-el6)
    f_create_client_package_el6
    f_create_server_package_el6
  ;;
  build-client-el6)
    f_create_client_package_el6
  ;;
  sign-client-rpm)
    f_sign_rpm ~/sshupdate/rpmbuild/client/RPMS/noarch/sshupdated-0.1-1.noarch.rpm
  ;;
  build-server-el6)
    f_create_server_package_el6
  ;;
  build-suse)
    f_create_client_package_suse
    f_create_server_package_suse
  ;;
  build-client-suse)
    f_create_client_package_suse
  ;;
  build-server-suse)
    f_create_server_package_suse
  ;;
  clean)
    rm -rf /var/tmp/${client_service_name}-root/
  ;;
  init)
    print_line "\n sshupdate - Patch Management over SSH\n"
    print_line "\nTo make sshupdate work it requires a node to be used as\n"
    print_line "a manager. By answering the following questions we will\n"
    print_line "guide you through the process of creating packages that\n"
    print_line "can be installed both on managers and clients that you\n"
    print_line "wish to control.\n\n"
    print_line "For additional information see:\n"
    print_line "https://github.com/trams242/sshupdate\n\n"
    print_line "The manager uses SSH-keys to communicate with each client\n"
    print_line "to make this work, we need to have some keys.\n\n"
    f_query_user "Do you already have keys generated that you'd like to use?" yes_no
    if [ "$?" = "0" ]
    then
      f_query_user "\nWhere are they located?" check_file
    else
      print_line "\nLet's generate you some keys.\n"
      f_genkeys
    fi
    if [ -f /etc/redhat-release ]
    then
      f_query_user "\nDo you want to create a client package?" yes_no
      [ $? = 0 ] && f_create_client_package_el6
      f_query_user "\nDo you want to create a server package?" yes_no
      [ $? = 0 ] && f_create_server_package_el6
    elif [ -f /etc/debian_version ]
    then
      f_query_user "\nDo you want to create a client package?" yes_no
      [ $? = 0 ] && f_create_client_package_deb
      f_query_user "\nDo you want to create a server package?" yes_no
      [ $? = 0 ] && f_create_server_package_deb
    elif [ -f /etc/SuSE-release ]
    then
      f_query_user "\nDo you want to create a client package?" yes_no
      [ $? = 0 ] && f_create_client_package_suse
      f_query_user "\nDo you want to create a server package?" yes_no
      [ $? = 0 ] && f_create_server_package_suse
    else
      echo "Im not sure which distribution you want to build packages for, skipping."
    fi
  ;;
  *)
    f_help
  ;;
esac
